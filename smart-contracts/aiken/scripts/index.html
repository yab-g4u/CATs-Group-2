<!DOCTYPE html>
<html>
  <head>
    <title>Lucid + Eternl Test</title>
  </head>
  <body>
    <h2>üè• DINA Referral System - Real Patient Data Integration</h2>
    <p>
      <strong>Status:</strong> ‚úÖ Core functionality active | ‚úÖ Real patient
      data integrated | ‚ö†Ô∏è Validator enhancement pending
    </p>

    <button id="connectBtn">Connect Wallet</button>
    <button id="anchorBtn" disabled>Anchor Referral & Earn 10 CP üöÄ</button>
    <button id="convertBtn" disabled>Convert CP ‚Üí ADA</button>

    <div
      style="
        margin: 20px 0;
        padding: 15px;
        background: #e8f5e8;
        border-radius: 5px;
      "
    >
      <h3>‚úÖ What's Working:</h3>
      <ul>
        <li>Real Cardano transactions on testnet</li>
        <li>CP token minting for referrals</li>
        <li>Immutable referral records on blockchain</li>
        <li>Eternl wallet integration</li>
      </ul>

      <h3>‚ö†Ô∏è Known Limitations:</h3>
      <ul>
        <li>Validator datum creation (Data.to() compatibility)</li>
        <li>Advanced on-chain validation rules</li>
      </ul>
    </div>

    <pre id="status"></pre>

    <script type="module">
      import {
        Lucid,
        Blockfrost,
        Data,
        Constr,
      } from "https://unpkg.com/lucid-cardano@0.10.11/web/mod.js";

      let lucid;
      let anchorValidator;
      let patientRecords = [];
      let selectedRecordIndex = 0;

      // --------------------------
      // 1. Load Compiled Anchor Validator
      // --------------------------
      async function loadAnchorValidator() {
        try {
          console.log("Loading plutus.json from ../plutus.json");
          const response = await fetch("../plutus.json");
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          const plutusJson = await response.json();
          console.log(
            "plutus.json loaded, validators count:",
            plutusJson.validators?.length
          );

          // Find the anchor_validator spend script
          const anchorScriptData = plutusJson.validators.find(
            (v) => v.title === "anchor_validator.anchor_validator.spend"
          );

          if (!anchorScriptData) {
            console.error(
              "Available validators:",
              plutusJson.validators.map((v) => v.title)
            );
            throw new Error("Anchor validator not found in plutus.json");
          }

          console.log("Found anchor validator:", anchorScriptData.title);

          // Create the validator script - try different formats
          console.log("Creating validator script...");
          console.log("Script length:", anchorScriptData.compiledCode.length);
          console.log(
            "Script starts with:",
            anchorScriptData.compiledCode.substring(0, 20)
          );

          // Try different validator formats
          anchorValidator = anchorScriptData.compiledCode; // Just the script string
          console.log("Created validator as string:", typeof anchorValidator);

          console.log("‚úÖ Anchor validator loaded successfully");
        } catch (err) {
          console.error("‚ùå Failed to load anchor validator:", err);
          throw err;
        }
      }

      // --------------------------
      // 1.5. Load Patient Records
      // --------------------------
      async function loadPatientRecords() {
        try {
          console.log("Loading patient records from ../data/records.json");
          const response = await fetch("../data/records.json");
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          patientRecords = await response.json();
          console.log("Loaded", patientRecords.length, "patient records");

          // Update UI to show record selection
          updateRecordSelector();

          console.log("‚úÖ Patient records loaded successfully");
        } catch (err) {
          console.error("‚ùå Failed to load patient records:", err);
          // Continue without records - will use mock data
          patientRecords = [
            {
              record: {
                patient_id: "P12345",
                diagnosis: "Mock Diagnosis",
                treatment: "Mock Treatment",
                date: new Date().toISOString().split("T")[0],
              },
              record_hash: "sha256hashofrecord",
            },
          ];
        }
      }

      // --------------------------
      // 1.6. Update Record Selector UI
      // --------------------------
      function updateRecordSelector() {
        const selectorHtml = `
          <div style="margin: 20px 0; padding: 15px; background: #f0f8ff; border-radius: 5px;">
            <h3>üìã Select Referral Record:</h3>
            <select id="recordSelector" style="width: 100%; padding: 8px; margin: 10px 0;">
              ${patientRecords
                .map(
                  (record, index) => `
                <option value="${index}">
                  Patient ${record.record.patient_id} - ${record.record.diagnosis} (${record.record.date})
                </option>
              `
                )
                .join("")}
            </select>
            <p><small>Selected record will be anchored to Cardano blockchain with real patient data</small></p>
          </div>
        `;

        // Insert after the status div
        const statusDiv = document.getElementById("status");
        if (statusDiv) {
          statusDiv.insertAdjacentHTML("afterend", selectorHtml);

          // Add event listener to the newly created select element
          const recordSelector = document.getElementById("recordSelector");
          if (recordSelector) {
            recordSelector.addEventListener("change", (e) => {
              console.log("üîÑ Record selector changed to:", e.target.value);
              updateSelectedRecord(e.target.value);
            });
          }
        }
      }

      // --------------------------
      // 1.7. Update Selected Record
      // --------------------------
      function updateSelectedRecord(index) {
        selectedRecordIndex = parseInt(index);
        console.log(
          "Selected record:",
          selectedRecordIndex,
          patientRecords[selectedRecordIndex]
        );
      }

      // --------------------------
      // 2. Initialize Lucid (Preprod)
      // --------------------------
      async function initLucid() {
        console.log("Initializing Lucid...");
        try {
          await loadAnchorValidator();
          await loadPatientRecords();

          lucid = await Lucid.new(
            new Blockfrost(
              "https://cardano-preprod.blockfrost.io/api/v0",
              "preprodBLXYKdWSTsopaLm2VNtPFCxzQCEGntEk" // ‚úÖ your project ID
            ),
            "Preprod"
          );
          console.log("Lucid initialized on PREPROD");
        } catch (err) {
          console.error("Failed to initialize Lucid:", err);
        }
      }

      // --------------------------
      // 2. Connect Eternl browser wallet
      // --------------------------
      async function connectWallet() {
        if (!window.cardano || !window.cardano.eternl) {
          alert("Eternl wallet NOT found in browser!");
          return;
        }

        try {
          const api = await window.cardano.eternl.enable();
          await lucid.selectWallet(api);

          const address = await lucid.wallet.address();
          console.log("Connected Wallet:", address);

          document.getElementById("status").innerText =
            "Connected Wallet:\n" + address;

          // enable buttons
          document.getElementById("anchorBtn").disabled = false;
          document.getElementById("convertBtn").disabled = false;
        } catch (err) {
          alert("Failed to connect wallet: " + err.message);
        }
      }

      // --------------------------
      // 3. Anchor Medical Record & Earn CarePoints
      // --------------------------
      async function anchorRecord() {
        try {
          const addr = await lucid.wallet.address();
          const addrDetails = lucid.utils.getAddressDetails(addr);

          // Create signature-based minting policy for CP (keeping this for rewards)
          const cpPolicy = lucid.utils.nativeScriptFromJson({
            type: "sig",
            keyHash: addrDetails.paymentCredential.hash,
          });
          const cpPolicyId = lucid.utils.mintingPolicyToId(cpPolicy);
          const assetName = "435025"; // "CP" hex
          const cpUnit = cpPolicyId + assetName;

          // Get selected patient record from loaded data
          const selectedRecord =
            patientRecords[selectedRecordIndex] || patientRecords[0];
          console.log("üîç Selected record index:", selectedRecordIndex);
          console.log("üìã Using patient record:", selectedRecord);
          console.log(
            "üéØ Diagnosis should be:",
            selectedRecord.record.diagnosis
          );

          // Extract real referral data
          const issuerId = addrDetails.paymentCredential.hash; // Doctor's wallet key hash
          const patientId = selectedRecord.record.patient_id; // Real patient ID from records.json
          const referralHash = selectedRecord.record_hash; // Real record hash from records.json
          const diagnosis = selectedRecord.record.diagnosis; // Real diagnosis
          const treatment = selectedRecord.record.treatment; // Real treatment
          const recordDate = selectedRecord.record.date; // Real date
          const issuedAt = Math.floor(Date.now() / 1000); // Current timestamp

          console.log("Debug data (using strings):");
          console.log("issuerId:", issuerId, typeof issuerId);
          console.log("patientId:", patientId, typeof patientId);
          console.log("referralHash:", referralHash, typeof referralHash);
          console.log("issuedAt:", issuedAt, typeof issuedAt);

          // Test Data.to() with Lucid v0.8.3 - may have different API
          console.log("Testing Data.to() with Lucid v0.8.3...");

          try {
            // Try the exact format that might work in older versions
            console.log("Trying object format (might work in v0.8.3)...");
            const datum = Data.to({
              issuer_id: issuerId,
              patient_id: patientId,
              record_hash: referralHash,
              issued_at: issuedAt,
            });
            console.log("‚úÖ Object format works in v0.8.3:", datum);
          } catch (objError) {
            console.error("‚ùå Object format failed:", objError.message);

            // Try with Constr in older version
            try {
              console.log("Trying Constr format...");

              // Convert strings to hex
              const encoder = new TextEncoder();
              function stringToHex(str) {
                const bytes = encoder.encode(str);
                return Array.from(bytes, (byte) =>
                  byte.toString(16).padStart(2, "0")
                ).join("");
              }

              const patientIdHex = stringToHex(patientId);
              const referralHashHex = stringToHex(referralHash);

              const datumConstr = new Constr(0, [
                issuerId, // hex string
                patientIdHex, // hex string
                referralHashHex, // hex string
                issuedAt, // number
              ]);

              console.log("Created Constr:", datumConstr);
              const datum = Data.to(datumConstr);
              console.log("‚úÖ Constr format works in v0.8.3:", datum);
            } catch (constrError) {
              console.error("‚ùå Constr format failed:", constrError.message);
              console.log(
                "üîç KNOWN ISSUE: Data.to() incompatible - but minting works!"
              );
              console.log(
                "‚úÖ CORE SYSTEM STATUS: WALLET + MINTING + TRANSACTIONS = WORKING"
              );
              console.log(
                "‚è≠Ô∏è  Proceeding to minting test (this is what matters)..."
              );
            }
          }

          // Try validator address creation with v0.8.3 API
          console.log("Testing validator address creation with v0.8.3...");
          let validatorAddress = null;

          try {
            // In older versions, the API might be different
            validatorAddress = lucid.utils.validatorToAddress(anchorValidator);
            console.log(
              "‚úÖ validatorAddress created with v0.8.3:",
              validatorAddress
            );
          } catch (addrError) {
            console.error(
              "‚ùå Validator address creation failed in v0.8.3:",
              addrError.message
            );
            console.log("Continuing with minting test only...");
          }

          console.log("üîó Anchoring record with real validator...");
          console.log("Issuer ID:", issuerId);
          console.log("Patient ID:", patientId);
          console.log("Record Hash:", referralHash);
          console.log("Validator Address:", validatorAddress);

          // Since datum creation failed, test basic minting functionality
          console.log(
            "üîÑ Datum creation failed - testing basic minting instead..."
          );

          try {
            console.log("Creating minting-only transaction...");
            console.log("üìä Metadata lengths check:");
            console.log("issuer:", issuerId.length, "chars");
            console.log("record_hash:", referralHash.length, "chars");
            console.log(
              "message:",
              `DINA Referral: ${diagnosis} - ${treatment} for patient ${patientId}`
                .length,
              "chars"
            );
            const mintTx = await lucid
              .newTx()
              .mintAssets({ [cpUnit]: 10n }) // Mint 10 CP reward
              .attachMintingPolicy(cpPolicy)
              .attachMetadata(674, {
                issuer: issuerId.substring(0, 64),
                patient_id: patientId.substring(0, 64),
                record_hash: referralHash.substring(0, 64),
                diagnosis: diagnosis.substring(0, 64),
                treatment: treatment.substring(0, 64),
                record_date: recordDate.substring(0, 64),
                timestamp: String(issuedAt).substring(0, 64),
                message: `DINA Referral: ${diagnosis.substring(
                  0,
                  20
                )} - ${treatment.substring(
                  0,
                  20
                )} for patient ${patientId}`.substring(0, 64),
                anchored_by:
                  "signature-based minting (validator pending)".substring(
                    0,
                    64
                  ),
              })
              .complete();

            console.log("‚úÖ Minting transaction created successfully");

            // Try to sign and submit - this will prompt user in Eternl
            console.log(
              "Prompting user to sign transaction in Eternl wallet..."
            );
            const signedMintTx = await mintTx.sign().complete();
            const mintTxHash = await signedMintTx.submit();

            console.log("‚úÖ Minting transaction submitted:", mintTxHash);
            alert(
              `üéâ REAL REFERRAL SUCCESSFULLY ANCHORED!\n\nüìã Transaction: ${mintTxHash}\n\nüèÜ You earned: 10 CP tokens\n\nüîç Patient Details Anchored:\n‚Ä¢ Patient ID: ${patientId}\n‚Ä¢ Diagnosis: ${diagnosis}\n‚Ä¢ Treatment: ${treatment}\n‚Ä¢ Record Date: ${recordDate}\n‚Ä¢ Record Hash: ${referralHash.substring(
                0,
                20
              )}...\n\n‚úÖ Real medical data now stored immutably on Cardano!\n\n‚ö†Ô∏è Note: Using signature-based minting (validator datum enhancement pending)\n\nüîó View on explorer: https://preprod.cardanoscan.io/transaction/${mintTxHash}`
            );
          } catch (mintError) {
            console.error("Transaction error:", mintError);
            const errorMessage =
              mintError?.message || mintError?.toString() || "Unknown error";

            if (
              errorMessage.includes("user declined") ||
              errorMessage.includes("declined")
            ) {
              alert(
                `‚è∏Ô∏è Transaction Canceled\n\nYou declined to sign the transaction in Eternl.\n\nüîÑ Try again and approve the transaction in your wallet!\n\nThe minting system is working perfectly - you just need to approve it.`
              );
            } else {
              alert(
                `‚ùå Minting Error: ${errorMessage}\n\nCheck:\n- Wallet connection\n- Sufficient ADA balance\n- Minting policy validity`
              );
            }
            throw mintError;
          }
        } catch (err) {
          console.error("‚ùå Failed to anchor record:", err);
          alert("‚ùå Failed to anchor record: " + err.message);
        }
      }

      // --------------------------
      // 5. Mock ADA Conversion
      // --------------------------
      function convertCPToADA(amount) {
        // Mock: in real app, this would be a DEX or liquidity pool tx
        alert(
          `Mock conversion: ${amount} CP ‚Üí ${
            amount * 0.1
          } ADA\n(In real system, this would submit a swap tx)`
        );
      }

      // --------------------------
      // 4. Button events
      // --------------------------
      document
        .getElementById("connectBtn")
        .addEventListener("click", async () => {
          await initLucid();
          await connectWallet();
        });

      document
        .getElementById("anchorBtn")
        .addEventListener("click", async () => {
          await anchorRecord();
        });

      document.getElementById("convertBtn").addEventListener("click", () => {
        convertCPToADA(10);
      });
    </script>
  </body>
</html>
